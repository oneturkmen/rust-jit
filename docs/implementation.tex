This section describes the high-level design and architecture of the project;
implementation challenges I faced while realizing the project; as well as
the details of the implementations of the borrow checker rules.
Despite facing numerous challenges, I managed to implement the project
\textit{partially}; it includes the front-end compiler and interpreter.
Integrating OMR's JIT compiler remains a future goal.

The source code open sourced and is available at \href{https://github.com/oneturkmen/rust-jit}{github.com/oneturkmen/rust-jit}.

\subsection{Design}

Before I present the design of the project, I must note that
the ideas for architecture as well as design patterns
were taken from the Crafting Interpreters book by Bob Nyrdstrom
\textcolor{red}{cite crafting interpreters book}.

The design of my implementation is similar to the one described
on \hyperref[arch1]{Figure 3}. The entire system works as a \textit{pipeline}
that takes in raw Rust code, transforms it into an IR, runs optimizations on it,
and finally, either directly executesit, or JIT-compiles the IR into machine code.

To make project's components more reusable (namely, the AST serving as an IR),
I resorted to a hybrid of two design patterns (namely, \textit{visitor} and
\textit{interpreter}). The hybrid approach also makes the implementation code
readable, testable, and extensible enough for future changes.

Each class in \texttt{ast.hpp} represents a corrensponding grammar rule. For
example, take a look at \hyperref[cpp1]{Figure 4}. \texttt{VarDeclStmt}
inherits from abstract \texttt{Stmt} class, and contains \texttt{Token m\_name;}
and \texttt{Expr* m\_initializer;} as l-value (variable name) and
r-value (value to declare a variable with), respectively.

Visitor pattern allows us to add additional functionality on the AST classes
without many changes. We only have to subclass a template class (as in
\hyperref[cpp2]{Figure 5}, pass a template argument that we want methods
to return, and provide implementation for these. As of AST classes,
we only need to add an additional method definitions to ``accept'' a visitor
class. This could be further improved by turning the code in \texttt{ast.hpp}
into a more generic variant.

\begin{figure*}[ht]
    \begin{center}
        \lstinputlisting{ast.cpp}
    \end{center}
    \caption{AST.hpp maps each rule to its own class.}
    \label{cpp1}
\end{figure*}

\begin{figure*}[ht]
    \begin{center}
        \lstinputlisting{astv.cpp}
    \end{center}
    \caption{ASTVisitor for any class that wants to ``visit'' an AST.}
    \label{cpp2}
\end{figure*}

\subsection{Challenges}

The current design was not the kick-starting idea. Initially, to transform Rust
code into the AST, I planned to use \textbf{syn} crate (package) from Rust's
ecosystem.  The package turns Rust into an IR without any issues, with the
exception that it generates too complex (to understand what I need from it,
\textit{exactly}) data structure that represent an MIR (or, an annotated
control-flow graph). In addition to the MIR's complexity, I immediately
realized that I will not be able to pass the data structure
to OMR as the latter currently needs C++ code to run.

As of a more fine-grained design, I initially thought to
have a large ``switch"" statement that would branch off
the control flow for each of the grammar rules. However,
this was clear to me that it is a naive (and quite \textit{bad} in many ways)
approach. I found the hybrid approach to be better; besides,
it was quite simple to understand that the AST classes would
represent grammar rules, visitor classes would traverse the AST
classes, and perform the necessary functionality without causing me much
pain.

\subsection{Borrow checker}

As previously explained, the borrow checker makes sure that
ownership principles are not violated at any given statement.
For the scope of this class, I implemented a simple borrow checker
that relies on two hash maps (\texttt{std::unordered\_map<>} in C++).
One map (\textbf{env}) stores local variables in a certain environment
(e.g., in a function). It maps variables to their values, as well as
the information about mutability (whether a variable's
value can be changed or not) and ownership (whether a variable's value is
borrowed) of the variable.

The other map (\textbf{pointer}) stores a pointer as a key, and the referenced value (i.e., where it points to) as a value. Similarly to \textbf{env}, \textbf{pointer} also stores
the mutability, but of the references.

In other words, we store the information about \textbf{ownership} and
\textbf{mutability} as boolean types. These ``flags'' help us determine
whether some statement (assignment expression or variable declaration) violates
the ownership rules.

Despite its logical simplicity, the graph representation would have been better
suited for tracking the ownership and mutability of objects. First, it is easier
to track references, especially nested ones, and visualize them (as a graph).
Second, a garbage collection framework, which will highly likely be introduced in future
to manage heaps, uses a graph representation to get rid of unused memory locations
(e.g., mark-and-sweep algorithm).
